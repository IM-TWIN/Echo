#old version- classify every 500 ms without majority voting

#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEScan.h>
#include <BLEAdvertisedDevice.h>
#include <Arduino.h>
#include <arduinoFFT.h>
#include "decision_tree.h"
#include "Wire.h"
#include <MPU6050_light.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <deque>
#include <math.h>
#include "Bluetooth_Lokahi.h"

// CONSTANTS
#define INTERVAL 33
#define SAMPLES 16            // Numero di campioni
#define SAMPLING_FREQUENCY 30 // Frequenza di campionamento in Hz
#define MAJORITY_SAMPLES 15 // Numero di campioni da considerare per la maggioranza
float vReal[SAMPLES]; // Vettore per le componenti reali
float vImag[SAMPLES]; // Vettore per le componenti immaginarie
ArduinoFFT<float> FFT = ArduinoFFT<float>(vReal, vImag, SAMPLES, SAMPLING_FREQUENCY);

float features[3 * (SAMPLES / 2)]; // Array per le magnitudini

int LED_BUILTIN = 2;
int LED_AIRPLANE = 32;
int LED_CAR = 25;

// Buffer per i dati dei sensori - PROCESSING
float xBuffer[SAMPLES];
float GyBuffer[SAMPLES];
float GzBuffer[SAMPLES];

int bufferIndex = 0;  // Indice corrente nel buffer

// Variabili per l'FFT
float fftResult[SAMPLES * 3];  // Array per memorizzare il risultato dell'FFT concatenato

int classificationBuffer[MAJORITY_SAMPLES]; // Buffer per le classificazioni
int majorityIndex = 0; // Indice corrente del buffer


MPU6050 mpu(Wire);
using namespace std;

// Variabili temporali ciclo acquisizione, 30 Hz
long prevMillis = 0;
unsigned long timestep = 0;
byte timestepByte = 0;
int durata = 0;
int prev_durata = 0;
bool identification = false;
void function_identify(bool identify);
void parse_commands(char* commands);
void function_(char* commands);
int current_function = 0;
bool send_diagnostic = false;

byte log_values[9];
float x = 0;
float y = 0;
float z = 0;
float Gx = 0;
float Gy = 0;
float Gz = 0;
float Ax = 0;
float Ay = 0;
float Az = 0;

void setup() {
  for (int i = 0; i < MAJORITY_SAMPLES; i++) {
    classificationBuffer[i] = -1; //riempe tutto di -1
  }
  Serial.begin(115200);
  Wire.begin();
  byte status = mpu.begin();
  Serial.print(F("MPU9250 status: "));
  Serial.println(status);
  while (status != 0) {}  // stop everything if could not connect to MPU6050
  Serial.println(F("Calculating offsets, do not move MPU6050"));
  delay(1000);
  // mpu.upsideDownMounting = true; // uncomment this line if the MPU6050 is mounted upside-down
  mpu.calcOffsets();  // gyro and accelerometer
  Serial.println("Done!\n");
  pinMode(LED_AIRPLANE, OUTPUT);
  pinMode(LED_CAR, OUTPUT);
  digitalWrite(LED_AIRPLANE, LOW);  // Spegne il LED_AIRPLANE
  digitalWrite(LED_CAR, LOW);       // Spegne il LED_CAR
  setup_BLE_ESP32();

  delay(200);
}

int v = 100;
int ver = 1;
int stat = 0;

void loop() {
  long curMillis = millis();
  if (curMillis - prevMillis >= INTERVAL) {
    long int start = millis();
    // 1  SENSORS READINGS
    mpu.update();

    x = float(mpu.getAngleX());
    y = float(mpu.getAngleY());
    z = float(mpu.getAngleZ());
    Gx = float(mpu.getGyroX()); //+- 500 deg/s
    Gy = float(mpu.getGyroY());
    Gz = float(mpu.getGyroZ());
    Ax = float(mpu.getAccX()); //+-2g
    Ay = float(mpu.getAccY());
    Az = float(mpu.getAccZ() - 1); // -1 compensa l'effetto della gravità
    //Serial.println(log_values[0]);
    // 2 TRANSMISSION
    log_values[0] = static_cast<byte>(mapfloat(Ax, -2, 2, 0, 255));  
    log_values[1] = static_cast<byte>(mapfloat(Ay, -2, 2, 0, 255));
    log_values[2] = static_cast<byte>(mapfloat(Az, -2, 2, 0, 255)); //+-4g RICONTROLLARE QUESTA COSA! controllare se in realtà è +-2g, basta cambiare i valori qui e min/max su godot
    log_values[3] = static_cast<byte>(mapAngleToByte(x));
    log_values[4] = static_cast<byte>(mapAngleToByte(y));
    log_values[5] = static_cast<byte>(mapAngleToByte(z));
    log_values[6] = static_cast<byte>(mapfloat(Gx, -500, 500, 0, 255));  
    log_values[7] = static_cast<byte>(mapfloat(Gy, -500, 500, 0, 255));
    log_values[8] = static_cast<byte>(mapfloat(Gz, -500, 500, 0, 255));

    //Serial.println(log_values[0]);

    logCharacteristic->setValue(log_values, 9);
    logCharacteristic->notify();
    std::string value = stringStreamCharacteristic->getValue();  // Simula una lettura
    //Serial.print("Button Read Value: "); //1 for airplane (Y) 0 for Car (Y)
    //Serial.println(value.c_str());
    if (!value.empty()) {
      int readValue = atoi(value.c_str());
      if (readValue == 0) {
        digitalWrite(LED_AIRPLANE, HIGH);
        digitalWrite(LED_CAR, LOW);
      } else if (readValue == 1) {
        digitalWrite(LED_AIRPLANE, LOW);
        digitalWrite(LED_CAR, HIGH);
      }
    }

    // 3 PREPROCESSING-FFT
    // Aggiungi i dati ai buffer
    xBuffer[bufferIndex] = x;
    GyBuffer[bufferIndex] = Gy;
    GzBuffer[bufferIndex] = Gz;

    // Incrementa l'indice del buffer
    bufferIndex++;

    // Controlla se il buffer è pieno
    if (bufferIndex >= SAMPLES) {
      // Resetta l'indice del buffer
      bufferIndex = 0;

      // Funzione per calcolare la FFT e ottenere le magnitudini
      auto calculateFFT = [](const float input[], float magnitudes[], int offset) {
        for (int i = 0; i < SAMPLES; i++) {
          vReal[i] = input[i];
          vImag[i] = 0.0f; // La parte immaginaria è zero
        }
        FFT.compute(FFTDirection::Forward);
        FFT.complexToMagnitude();
        for (int i = 0; i < SAMPLES / 2; i++) {
          magnitudes[offset + i] = vReal[i];
        }
      };

      // Calcola la FFT per ogni canale e concatena le magnitudini
      calculateFFT(xBuffer, features, 0);
      calculateFFT(GyBuffer, features, SAMPLES / 2);
      calculateFFT(GzBuffer, features, SAMPLES);
      /*// Stampa le magnitudini concatenate
      Serial.println("Magnitudini calcolate:");
      for (int i = 0; i < 3 * (SAMPLES / 2); i++) {
      Serial.print(features[i]);  ////magnitude va in ingresso al decision tree - se non va ricontrollare i dati
      Serial.print(" ");
      }
      */
      int classification = classify(features);
      //MAJORITY

      //



      String classificationString;

      switch (classification) {
        case 0:
          classificationString = "AIRPLANE";
          break;
        case 1:
          classificationString = "CAR";
          break;
        case 2:
          classificationString = "WALKING";
          break;
        case 3:
          classificationString = "IGNORING";
          break;
        default:
          classificationString = "UNKNOWN";
          break;
      }

      Serial.print("Classified as: "); //classificazione ogni 500 ms circa
      Serial.println(classificationString);
    }

    // Conteggio
    long int ende = millis();
    durata = ende - start;
    prev_durata = durata;
    prevMillis = curMillis;
    timestep++;
    // Mi aspetto che cicli da 0 a 255
    timestepByte++;
  }
}

float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float euler_to_byte(float angle_in_degrees) {
  // Normalizza l'angolo tra 0 e 360 gradi
  float normalized_angle = angle_in_degrees;
  while (normalized_angle >= 360.0) {
    normalized_angle -= 360.0;
  }
  while (normalized_angle < 0.0) {
    normalized_angle += 360.0;
  }

  // Mappa [0, 360] a [0, 255]
  float byte_value = (normalized_angle / 360.0) * 255.0;

  return byte_value;
}

float mapAngleToByte(float angle_degrees) {
  // Normalizza l'angolo tra [0, 360)
  while (angle_degrees >= 360.0) {
    angle_degrees -= 360.0;
  }
  while (angle_degrees < 0.0) {
    angle_degrees += 360.0;
  }

  // Mappa [0, 360) a [0, 255] byte range centrato attorno a 128
  byte byte_value = (byte)((angle_degrees / 360.0) * 255 + 128) % 256;

  return byte_value;
}

void write_float(byte* buff, const float value) {
  const byte* addr = reinterpret_cast<const byte*>(&value);
  for (int i = 0; i != 4; i++)
    *buff++ = *addr++;
}

void parse_commands(char* commands) {
  Serial.print("[DEBUG][Lokahi.ino] parse_commands()\n\t");
  Serial.print("...parsing command, whole content is: ");
  Serial.print(commands); // NOT SURE IT IS CORRECT THE PRINT OF A CHAR POINTER, CHECK!
  Serial.print("\n\t");

  // Splitting command in tokens separated by comma
  char* token = strtok(commands, ",");

  while (token != NULL) {
    String command = String(token);

    if (command.startsWith("Lokahi_test")) {
      Serial.print("Command: Lokahi test");
      Serial.println(command);
    } else if (command.startsWith("Lokahi_test_2")) {
      Serial.print("Command: Lokahi test_2");
      Serial.println(command);
    }
    else if (command.startsWith("Id")) {  // THIS IS the identification on device during connect phase! Id0 means stop identity
      Serial.print("Token is: ");
      Serial.println(command);

      command.remove(0, 2);
      int id = atoi(command.c_str());

      identification = id > 0;

      function_identify(identification);

      // This means that connection has been confirmed and we reset to initial function
      if (id == 0) {
        // In LOKAHI still we have no reset() neither InitFunction()
        // reset();
        // InitFunction5();
      } else {
        Serial.print("[WARNING!] command not recognized!\n\n");
      }
    }  // ...and so on for other commands

    // Last row of while loop
    token = strtok(NULL, ",");
  }  // Close while loop, and function parse_commands() ends
}

void function_identify(bool enable) {
  Serial.print("[DEBUG][Lokahi.ino] function_identify()\n\t");
  Serial.print("enable is: ");
  Serial.println(enable);
  Serial.println();

  if (enable) {
    // Add functionality here
  } else {
    // Add functionality here
  }
}

void Init_Function0() {
  // TO BE FILLED FOR LOKAHI
  current_function = 0;
} 
